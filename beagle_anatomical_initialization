#!/usr/bin/env ruby
# ==============================================================================
# Purpose:
#     Initialize the anatomically-based Beagle output subdirectories.
#
# ==============================================================================

require 'optparse'
require 'ostruct'
require 'pathname'
require 'fileutils'
require 'tmpdir'            # needed for Dir::tmpdir

# load ruby gems
require 'rubygems'
require 'json'
require 'pp'

# load external dependencies
require 'hclab_function_library'
require 'beagle_function_library'
require 'beagle_logger_classes'

# start of main script
begin
   opt                     = OpenStruct.new{}   # store input options
   opt.verbose             = false
   opt.debug               = false
   opt.keyname             = ""
   opt.scanDate            = ""
   opt.scanId              = ""                 # this is a derived value
   opt.settingsFile        = ""

   # List of arguments.
   opts = OptionParser.new do |opts|
      opts.banner = "Usage: #{$0} [Options]"
      opts.separator ""
      opts.separator "Options:"

      opts.on('-v', '--[no-]verbose', 'Run verbosely') { |v| opt.verbose = v }

      opts.on('-d', '--debug', 'Print pedantic debugging messages') { |d| opt.debug = d }
   
      opts.on('--keyname subject_keyname', "Anonymizing keyname for this subject") do |keyname|
         opt.keyname = keyname
         puts "** keyname: " + opt.keyname if opt.verbose
      end

      opts.on('--scanDate scan_date', "Format YYYYMMDD") do |scanDate|
         opt.scanDate = scanDate
         puts "** scan date: " + opt.scanDate if opt.verbose
      end

      opts.on('--settingsFile aggregated_settings_file', "Fullpath to the aggregated settings file ") do |settingsFile|
         opt.settingsFile = settingsFile.to_s
         puts "** Fullpath to the aggregated settings file: " + opt.settingsFile if opt.verbose
      end

      opts.on_tail("-h", "--help", "Show this very helpful help message") do
         puts opts
         exit
      end

   end  # OptionParser

   # run parse!() method in the OptionParser object, passing ARGV
   # NB: the "!" in parse!() removes the switches from ARGV
   puts "Before OptionParser start ..." if opt.debug
   begin
      opts.parse!(ARGV)
   rescue Exception => e
      puts e, "", opts
      exit
   end



   # = = = = = = = =   M A I N   P R O C E S S I N G   S T A R T S   H E R E   = = = = = = =
   #

   # check for aggregated settings file, then read if all looks OK
   if ( opt.settingsFile.empty? || opt.keyname.empty? ) then
      puts "\n*** Error: Missing option(s) -- keyname or Loris aggregated settings file"
      puts opts
      exit
   end
   #
   if ( !File.exists?(opt.settingsFile) || !File.file?(opt.settingsFile) ) then
      puts sprintf("\n!!! Error: The specified Loris aggregated settings [%s] does not exist or is unreadable.", opt.settingsFile)
      exit
   end
   #
   settings = load_beagle_aggregated_settings(opt.settingsFile, verbose=false, debug=false)


   # init selected variables
   LORIS_ROOT_DIR = settings['LORIS_ROOT_DIR']
   CIVET_VERSION = settings['CIVET_VERSION']
   CIVET_ROOT_DIR = settings['CIVET_ROOT_DIR']
   
   CIVET_PREFIX = settings['CIVET_PREFIX'] + '_'
   CIVET_FINAL_T1_VOLUME_SUFFIX = settings['CIVET_FINAL_T1_VOLUME_SUFFIX']
   CIVET_SURFACE_GRAY_LEFT_SUFFIX = settings['CIVET_SURFACE_GRAY_LEFT_SUFFIX']
   CIVET_SURFACE_GRAY_RIGHT_SUFFIX = settings['CIVET_SURFACE_GRAY_RIGHT_SUFFIX']



   # set some useful values
   opt.scanId = opt.keyname + '-' + opt.scanDate
   keyname_dir_fullPath = File.join(settings['LORIS_ROOT_DIR'], opt.keyname)



   # check Civet ID directory ... just make sure it's there, and then
   # ... create sub-directories, as required
   civetId_dir_fullPath = File.join(CIVET_ROOT_DIR, opt.scanId)
   if ( !File.exists?(civetId_dir_fullPath) || !File.directory?(civetId_dir_fullPath) ) then
      puts sprintf("\n!!! Error: Civet validation error for scan %s", opt.scanId)
      puts sprintf("Civet ID subdirectory [%s] does not exist", civetId_dir_fullPath)
      exit
   end


   # load subject's master logfile; write a start message
   progname = 'beagle_anatomical_initialization'
   logger = BeagleLogger.new(opt.keyname, settings, eraseLog=false)
   logger.log_start_message(progname, opt.keyname, 'anatomical', opt.scanDate)
   logger.log_message(progname, opt.keyname, 'anatomical', opt.scanDate, 'civet_version', CIVET_VERSION)


   # new create anatomically-based subdirs within this directory
   #
   # -- AAL
   aal_subdir_name = 'AAL-' + opt.scanDate
   filename = File.join(keyname_dir_fullPath, aal_subdir_name)
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end
   # write ID of associated anatomical scan into the directory
   File.open(File.join(filename,'civet_scan_id.txt'), 'w') {|f| f.write("#{opt.scanId}\n");f.close}
   #
   filename = File.join(keyname_dir_fullPath, aal_subdir_name, "logs")
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end
   #
   filename = File.join(keyname_dir_fullPath, aal_subdir_name, "images")
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end


   # -- MASKS
   masks_subdir_name = 'MASKS-' + opt.scanDate
   filename = File.join(keyname_dir_fullPath, masks_subdir_name)
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end
   # write ID of associated anatomical scan into the directory
   File.open(File.join(filename,'civet_scan_id.txt'), 'w') {|f| f.write("#{opt.scanId}\n");f.close}
   #
   filename = File.join(keyname_dir_fullPath, masks_subdir_name, "logs")
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end


   # -- VBM
   vbm_subdir_name = 'VBM-' + opt.scanDate
   filename = File.join(keyname_dir_fullPath, vbm_subdir_name)
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end
   # write ID of associated anatomical scan into the directory
   File.open(File.join(filename,'civet_scan_id.txt'), 'w') {|f| f.write("#{opt.scanId}\n");f.close}
   #
   filename = File.join(keyname_dir_fullPath, vbm_subdir_name, "logs")
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end
   #
   filename = File.join(keyname_dir_fullPath, vbm_subdir_name, "images")
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end


   # -- THICKNESS
   thickness_subdir_name = 'THICKNESS-' + opt.scanDate
   filename = File.join(keyname_dir_fullPath, thickness_subdir_name)
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end
   # write ID of associated anatomical scan into the directory
   File.open(File.join(filename,'civet_scan_id.txt'), 'w') {|f| f.write("#{opt.scanId}\n");f.close}
   #
   filename = File.join(keyname_dir_fullPath, thickness_subdir_name, "tmp")
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end
   #
   filename = File.join(keyname_dir_fullPath, thickness_subdir_name, "logs")
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end
   #
   filename = File.join(keyname_dir_fullPath, thickness_subdir_name, "images")
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end


   # -- VISUALIZATION
   filename = File.join(keyname_dir_fullPath, "visualization")
   if !File.exists?( filename ) then FileUtils.mkdir( filename ) end

   # put a copy of various Civet files in here, for visualization convenience
   # ... final spatially normalized T1 volume
   civetId_dir_fullPath = File.join(CIVET_ROOT_DIR, opt.scanId)
   from_filename = CIVET_PREFIX + opt.scanId + CIVET_FINAL_T1_VOLUME_SUFFIX
   from_filename_fullPath = File.join(civetId_dir_fullPath, 'final', from_filename)
   to_dir = File.join(keyname_dir_fullPath, "visualization")
   to_filename_fullPath = File.join(to_dir, from_filename)
   if !File.exists?( to_filename_fullPath ) then FileUtils.cp(from_filename_fullPath, to_dir) end
   #
   # ... left hemisphere gray matter surface
   civetId_dir_fullPath = File.join(CIVET_ROOT_DIR, opt.scanId)
   from_filename = CIVET_PREFIX + opt.scanId + CIVET_SURFACE_GRAY_LEFT_SUFFIX
   from_filename_fullPath = File.join(civetId_dir_fullPath, 'surfaces', from_filename)
   to_dir = File.join(keyname_dir_fullPath, "visualization")
   to_filename_fullPath = File.join(to_dir, from_filename)
   if !File.exists?( to_filename_fullPath ) then FileUtils.cp(from_filename_fullPath, to_dir) end
   #
   # ... right hemisphere gray matter surface
   civetId_dir_fullPath = File.join(CIVET_ROOT_DIR, opt.scanId)
   from_filename = CIVET_PREFIX + opt.scanId + CIVET_SURFACE_GRAY_RIGHT_SUFFIX
   from_filename_fullPath = File.join(civetId_dir_fullPath, 'surfaces', from_filename)
   to_dir = File.join(keyname_dir_fullPath, "visualization")
   to_filename_fullPath = File.join(to_dir, from_filename)
   if !File.exists?( to_filename_fullPath ) then FileUtils.cp(from_filename_fullPath, to_dir) end

   # log a 'done' message to the subject's master logfile, and then write out logfile
   logger.log_stop_message(progname, opt.keyname, 'anatomical', opt.scanDate)
   logger.save_to_file()


rescue RuntimeError => e
   STDERR.puts e
   exit 1
end  #main()

